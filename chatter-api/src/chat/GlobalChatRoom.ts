import Client from "../stream/Client";
import IStreamObserver from "../stream/IStreamObserver";

import {
    config,
    ReceiveChatObject,
    RoomObject,
    SendChatObject,
    SendRoomsObject,
    StatusObject,
    StreamEvents
} from "../lib/utility";

/**
 * Represents an individual server-side chat room <br />
 * Listens for global client connections, disconnections, and messages to this room
 * @author Connell Reffo
 */
export default class GlobalChatRoom implements IStreamObserver {

    /**
     * Set of unique clients connected to this chat room
     */
    protected clients: Set<Client>;

    /**
     * Name of this chat room
     */
    protected name: string;

    /**
     * Unique ID of this chat room <br />
     * Generated by the factory
     */
    protected id: number;

    /**
     * Base constructor
     * @param name The name of this room
     * @param id The ID of this room
     */
    private constructor(name: string, id: number) {
        this.name = name;
        this.id = id;
        this.clients = new Set<Client>;
    }

    /**
     * @inheritDoc
     */
    public onClientConnected(client: Client): void {
        this.clients.add(client);
    }

    /**
     * @inheritDoc
     */
    public onClientDisconnected(client: Client): void {
        this.clients.delete(client);
    }

    /**
     * @inheritDoc
     */
    public onClientMessage(client: Client, message: ReceiveChatObject): void {
        const data: SendChatObject = {
            username: client.getName(),
            roomId: message.roomId,
            message: message.text
        };

        const status: StatusObject = this.verifyClientMessage(message);

        if (status.success) {
            this.broadcast(StreamEvents.SERVER_CHAT_RESPONSE, data);
        }
        else {
            client.emit(StreamEvents.SERVER_SEND_STATUS, status);
        }
    }

    /**
     * Verifies that a message received by this room is valid to be broadcast <br />
     * Essentially a filter
     * @param message The message to be verified
     */
    public verifyClientMessage(message: ReceiveChatObject): StatusObject {
        let success: boolean = false;

        if (typeof message.text == "string") {
            if (this.id == message.roomId && message.text.length >= config.MIN_MESSAGE_LENGTH && message.text.length <= config.MAX_MESSAGE_LENGTH) {
                success = true;
            }
        }

        return {
            success: success
        };
    }

    /**
     * Emits a message to every client stream connected to this room
     * @param event The event to emit
     * @param data The data to be sent
     */
    public broadcast(event: StreamEvents, data: {}): void {
        this.clients.forEach((client: Client): void => {
            client.emit(event, data);
        });
    }

    /**
     * Gets the name of this chat room
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Gets the ID of this chat room
     */
    public getID(): number {
        return this.id;
    }

    /**
     * Factory class that must be used to instantiate new chat rooms
     * @author Connell Reffo
     */
    public static Factory = class {

        /**
         * List of rooms instantiated by this factory
         */
        private static rooms: GlobalChatRoom[] = [];

        /**
         * Creates a new chat room object
         * @static
         * @param name The name of the room
         */
        public static instantiate(name: string): GlobalChatRoom {
            let room: GlobalChatRoom = new GlobalChatRoom(name, this.rooms.length);
            this.rooms.push(room);

            return room;
        }

        /**
         * Encodes the rooms this factory has instantiated as an object
         */
        public static encode(): SendRoomsObject {
            let roomObjects: RoomObject[] = [];

            this.rooms.forEach((room: GlobalChatRoom): void => {
                roomObjects.push({
                    name: room.getName(),
                    id: room.getID()
                });
            });

            return {
                rooms: roomObjects
            };
        }

        /**
         * <b>WARNING</b><br />
         * This method should only be used in test cases
         */
        public static reset(): void {
            this.rooms = [];
        }
    }
}